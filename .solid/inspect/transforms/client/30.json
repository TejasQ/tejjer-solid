{
  "id": "/Users/tejas/Sites/LAB/tejjer/node_modules/.pnpm/solid-start@0.2.6_i2cnpwj3ojjdnkycik5yjsstli/node_modules/solid-start/data/createRouteAction.tsx",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "solid"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { useNavigate, useSearchParams, type Navigator } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl, FormProps } from \"./Form\";\n\nimport type { ParentComponent } from \"solid-js\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { ServerFunctionEvent } from \"../server/types\";\nimport { refetchRouteData } from \"./createRouteData\";\n\ninterface ActionEvent extends ServerFunctionEvent {}\nexport interface Submission<T, U> {\n  input: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}\n\nexport type RouteAction<T, U> = [\n  {\n    pending: boolean;\n    input?: T;\n    result?: U;\n    error?: any;\n    clear: () => void;\n    retry: () => void;\n  },\n  ((vars: T) => Promise<U>) & {\n    Form: T extends FormData ? ParentComponent<FormProps> : never;\n    url: string;\n  }\n];\nexport type RouteMultiAction<T, U> = [\n  Submission<T, U>[] & { pending: Submission<T, U>[] },\n  ((vars: T) => Promise<U>) & {\n    Form: T extends FormData ? ParentComponent<FormProps> : never;\n    url: string;\n  }\n];\n\nexport type Invalidate = ((r: Response) => string | any[] | void) | string | any[];\n\nexport function createRouteAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [input, setInput] = createSignal<T | undefined>(init.input);\n  const [result, setResult] = createSignal<{ data?: U; error?: any } | undefined>(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables: T) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p\n      .then(async data => {\n        if (reqId === count) {\n          if (data instanceof Response) {\n            await handleResponse(data, navigate, options);\n          } else await handleRefetch(data as any[], options);\n          if (!data || isRedirectResponse(data)) setInput(undefined);\n          else setResult({ data });\n        }\n        return data;\n      })\n      .catch(async e => {\n        if (reqId === count) {\n          if (e instanceof Response) {\n            await handleResponse(e, navigate, options);\n          }\n          if (!isRedirectResponse(e)) {\n            setResult({ error: e });\n          } else setInput(undefined);\n        }\n        return undefined;\n      }) as Promise<U>;\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as T extends FormData ? ParentComponent<FormProps> : never;\n\n  return [\n    {\n      get pending() {\n        return !!input() && !result();\n      },\n      get input() {\n        return input();\n      },\n      get result() {\n        return result()?.data;\n      },\n      get error(): any {\n        return result()?.error;\n      },\n      clear() {\n        batch(() => {\n          setInput(undefined);\n          setResult(undefined);\n        });\n      },\n      retry() {\n        const variables = input();\n        if (!variables) throw new Error(\"No submission to retry\");\n        submit(variables);\n      }\n    },\n    submit\n  ];\n}\n\nexport function createRouteMultiAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteMultiAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [submissions, setSubmissions] = createSignal<Submission<T, U>[]>(\n    init.input ? [createSubmission(init.input)[0]] : []\n  );\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n\n  function createSubmission(variables: T) {\n    let submission: {\n      input: T,\n      readonly result: U | undefined,\n      readonly error: Error | undefined,\n      clear(): void,\n      retry(): void\n    };\n    const [result, setResult] = createSignal<{ data?: U; error?: any }>();\n    return [\n      (submission = {\n        input: variables,\n        get result() {\n          return result()?.data;\n        },\n        get error() {\n          return result()?.error;\n        },\n        clear() {\n          setSubmissions(v => v.filter(i => i.input !== variables));\n        },\n        retry() {\n          setResult(undefined);\n          return event && handleSubmit(fn(variables, event));\n        }\n      }),\n      handleSubmit\n    ] as const;\n    function handleSubmit(p: Promise<Response & { body: U } | U>): Promise<U> {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data as any[], options);\n        data ? setResult({ data }) : submission.clear();\n\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({ error: e });\n        } else submission.clear();\n      });\n      return p as Promise<U>;\n    }\n  }\n  function submit(variables: T) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as T extends FormData ? ParentComponent<FormProps> : never;\n\n  return [\n    new Proxy<Submission<T, U>[] & { pending: Submission<T, U>[] }>([] as any, {\n      get(_, property) {\n        if (property === $TRACK) return submissions();\n        if (property === \"pending\") return submissions().filter(sub => !sub.result);\n        return submissions()[property as keyof typeof submissions];\n      }\n    }),\n    submit\n  ];\n}\n\nfunction handleRefetch(response: Response | string | any[], options: { invalidate?: Invalidate } = {}) {\n  return refetchRouteData(\n    typeof options.invalidate === \"function\" ? options.invalidate(response as Response) : options.invalidate\n  );\n}\n\nfunction handleResponse(response: Response, navigate: Navigator, options?: { invalidate?: Invalidate }) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n\n  if (isRedirectResponse(response)) return handleRefetch(response, options);\n}\n\nfunction checkFlash<T>(fn: any) {\n  const [params] = useSearchParams();\n\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== (fn as any).url) {\n    return {};\n  }\n\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error\n        ? new FormError(param.error.message, {\n            fieldErrors: param.error.fieldErrors,\n            stack: param.error.stack,\n            form: param.error.form,\n            fields: param.error.fields\n          })\n        : undefined\n    },\n    input: input as unknown as T\n  };\n}\n",
      "start": 1669937513075,
      "end": 1669937513178
    },
    {
      "name": "solid",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { useNavigate, useSearchParams } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, useContext } from \"solid-js\";\nimport { FormError, FormImpl } from \"./Form\";\nimport { isRedirectResponse } from \"../server/responses\";\nimport { ServerContext, useRequest } from \"../server/ServerContext\";\nimport { refetchRouteData } from \"./createRouteData\";\nexport function createRouteAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [input, setInput] = createSignal(init.input);\n  const [result, setResult] = createSignal(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables) {\n    const p = fn(variables, event);\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p.then(async data => {\n      if (reqId === count) {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n        } else await handleRefetch(data, options);\n        if (!data || isRedirectResponse(data)) setInput(undefined);else setResult({\n          data\n        });\n      }\n      return data;\n    }).catch(async e => {\n      if (reqId === count) {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        }\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else setInput(undefined);\n      }\n      return undefined;\n    });\n  }\n  submit.url = fn.url;\n  submit.Form = props => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [{\n    get pending() {\n      return !!input() && !result();\n    },\n    get input() {\n      return input();\n    },\n    get result() {\n      return result()?.data;\n    },\n    get error() {\n      return result()?.error;\n    },\n    clear() {\n      batch(() => {\n        setInput(undefined);\n        setResult(undefined);\n      });\n    },\n    retry() {\n      const variables = input();\n      if (!variables) throw new Error(\"No submission to retry\");\n      submit(variables);\n    }\n  }, submit];\n}\nexport function createRouteMultiAction(fn, options = {}) {\n  let init = checkFlash(fn);\n  const [submissions, setSubmissions] = createSignal(init.input ? [createSubmission(init.input)[0]] : []);\n  const navigate = useNavigate();\n  const event = useContext(ServerContext);\n  function createSubmission(variables) {\n    let submission;\n    const [result, setResult] = createSignal();\n    return [submission = {\n      input: variables,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      clear() {\n        setSubmissions(v => v.filter(i => i.input !== variables));\n      },\n      retry() {\n        setResult(undefined);\n        return event && handleSubmit(fn(variables, event));\n      }\n    }, handleSubmit];\n    function handleSubmit(p) {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data, options);\n        data ? setResult({\n          data\n        }) : submission.clear();\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({\n            error: e\n          });\n        } else submission.clear();\n      });\n      return p;\n    }\n  }\n  function submit(variables) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = fn.url;\n  submit.Form = props => {\n    let url = fn.url;\n    return _$createComponent(FormImpl, _$mergeProps(props, {\n      action: url,\n      onSubmission: submission => {\n        submit(submission.formData);\n      },\n      get children() {\n        return props.children;\n      }\n    }));\n  };\n  return [new Proxy([], {\n    get(_, property) {\n      if (property === $TRACK) return submissions();\n      if (property === \"pending\") return submissions().filter(sub => !sub.result);\n      return submissions()[property];\n    }\n  }), submit];\n}\nfunction handleRefetch(response, options = {}) {\n  return refetchRouteData(typeof options.invalidate === \"function\" ? options.invalidate(response) : options.invalidate);\n}\nfunction handleResponse(response, navigate, options) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n  }\n  if (isRedirectResponse(response)) return handleRefetch(response, options);\n}\nfunction checkFlash(fn) {\n  const [params] = useSearchParams();\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== fn.url) {\n    return {};\n  }\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error ? new FormError(param.error.message, {\n        fieldErrors: param.error.fieldErrors,\n        stack: param.error.stack,\n        form: param.error.form,\n        fields: param.error.fields\n      }) : undefined\n    },\n    input: input\n  };\n}",
      "start": 1669937513178,
      "end": 1669937513193
    }
  ],
  "virtual": false
}