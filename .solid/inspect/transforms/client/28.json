{
  "id": "/Users/tejas/Sites/LAB/tejjer/node_modules/.pnpm/solid-start@0.2.6_i2cnpwj3ojjdnkycik5yjsstli/node_modules/solid-start/data/Form.tsx",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "solid"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { ComponentProps, createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\n\nexport interface FormAction<Data> {\n  action: string;\n  method: string;\n  formData: Data;\n  encType: string;\n}\n\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\n\ntype FormEncType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target:\n      | HTMLFormElement\n      | HTMLButtonElement\n      | HTMLInputElement\n      | FormData\n      | URLSearchParams\n      | { [name: string]: string }\n      | null,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n\nexport interface FormProps extends Omit<ComponentProps<\"form\">, \"method\" | \"onSubmit\"> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   *\n   * Note: If JavaScript is disabled, you'll need to implement your own \"method\n   * override\" to support more than just GET and POST.\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Normal `<form encType>`.\n   *\n   * Note: Remix only supports `application/x-www-form-urlencoded` right now\n   * but will soon support `multipart/form-data` as well.\n   */\n  // encType?: FormEncType;\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  onSubmit?: (event: SubmitEvent) => void;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not be called.\n   */\n  onSubmission?: (submission: FormAction<FormData>) => void;\n}\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\ninterface FormImplProps extends FormProps {\n  onSubmmsion?: (submission: FormAction<FormData>) => void;\n}\n\nexport let FormImpl = (_props: FormImplProps) => {\n  let [props, rest] = splitProps(\n    mergeProps(\n      {\n        reloadDocument: false,\n        replace: false,\n        method: \"post\" as FormMethod,\n        action: \"/\",\n        encType: \"application/x-www-form-urlencoded\" as FormEncType\n      },\n      _props\n    ),\n    [\n      \"reloadDocument\",\n      \"replace\",\n      \"method\",\n      \"action\",\n      \"encType\",\n      \"onSubmission\",\n      \"onSubmit\",\n      \"children\",\n      \"ref\"\n    ]\n  );\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod: FormMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef: HTMLButtonElement | HTMLInputElement | null = null;\n  let form: HTMLFormElement | null = null;\n\n  createEffect(() => {\n    if (!form) return;\n\n    function handleClick(event: MouseEvent) {\n      if (!(event.target instanceof HTMLElement)) return;\n      let submitButton = event.target.closest<HTMLButtonElement | HTMLInputElement>(\n        \"button,input[type=submit]\"\n      );\n\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (\n    <form\n      ref={f => {\n        form = f;\n        if (typeof props.ref === \"function\") props.ref(f);\n      }}\n      method={formMethod}\n      action={_props.action}\n      enctype={props.encType}\n      // encType={encType}\n      onSubmit={\n        props.reloadDocument\n          ? undefined\n          : event => {\n              props.onSubmit && props.onSubmit(event);\n              if (event.defaultPrevented) return;\n              event.preventDefault();\n              submit(clickedButtonRef || event.currentTarget, {\n                method: props.method,\n                replace: props.replace\n              });\n              clickedButtonRef = null;\n            }\n      }\n      {...rest}\n    >\n      {props.children}\n    </form>\n  );\n};\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  // encType?: FormEncType;\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n\nexport function useSubmitImpl(\n  onSubmission: (sub: FormAction<FormData>) => void\n): SubmitFunction {\n  return (target, options = {}) => {\n    let method: string;\n    let action: string;\n    let encType: string;\n    let formData: FormData;\n\n    if (isFormElement(target)) {\n      let submissionTrigger: HTMLButtonElement | HTMLInputElement = (options as any)\n        .submissionTrigger;\n\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (\n      isButtonElement(target) ||\n      (isInputElement(target) && (target.type === \"submit\" || target.type === \"image\"))\n    ) {\n      let form = target.form;\n\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(\n          `Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`\n        );\n      }\n\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n\n    let { protocol, host } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n\n    let submission: FormAction<FormData> = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n",
      "start": 1669937513199,
      "end": 1669937513261
    },
    {
      "name": "solid",
      "result": "import { template as _$template } from \"solid-js/web\";\nimport { getNextElement as _$getNextElement } from \"solid-js/web\";\nimport { runHydrationEvents as _$runHydrationEvents } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\nimport { setAttribute as _$setAttribute } from \"solid-js/web\";\nimport { use as _$use } from \"solid-js/web\";\nimport { spread as _$spread } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { memo as _$memo } from \"solid-js/web\";\nconst _tmpl$ = /*#__PURE__*/_$template(`<form></form>`, 2);\n/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\nexport let FormImpl = _props => {\n  let [props, rest] = splitProps(mergeProps({\n    reloadDocument: false,\n    replace: false,\n    method: \"post\",\n    action: \"/\",\n    encType: \"application/x-www-form-urlencoded\"\n  }, _props), [\"reloadDocument\", \"replace\", \"method\", \"action\", \"encType\", \"onSubmission\", \"onSubmit\", \"children\", \"ref\"]);\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef = null;\n  let form = null;\n  createEffect(() => {\n    if (!form) return;\n    function handleClick(event) {\n      if (!(event.target instanceof HTMLElement)) return;\n      let submitButton = event.target.closest(\"button,input[type=submit]\");\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (() => {\n    const _el$ = _$getNextElement(_tmpl$);\n    _$use(f => {\n      form = f;\n      if (typeof props.ref === \"function\") props.ref(f);\n    }, _el$);\n    _$setAttribute(_el$, \"method\", formMethod);\n    _$spread(_el$, _$mergeProps({\n      get action() {\n        return _props.action;\n      },\n      get enctype() {\n        return props.encType;\n      },\n      get onSubmit() {\n        return props.reloadDocument ? undefined : event => {\n          props.onSubmit && props.onSubmit(event);\n          if (event.defaultPrevented) return;\n          event.preventDefault();\n          submit(clickedButtonRef || event.currentTarget, {\n            method: props.method,\n            replace: props.replace\n          });\n          clickedButtonRef = null;\n        };\n      }\n    }, rest), false, true);\n    _$insert(_el$, () => props.children);\n    _$runHydrationEvents();\n    return _el$;\n  })();\n};\nexport function useSubmitImpl(onSubmission) {\n  return (target, options = {}) => {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    if (isFormElement(target)) {\n      let submissionTrigger = options.submissionTrigger;\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n      let form = target.form;\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`);\n      }\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n    let {\n      protocol,\n      host\n    } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n    let submission = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}",
      "start": 1669937513261,
      "end": 1669937513274
    }
  ],
  "virtual": false
}