{
  "id": "/Users/tejas/Sites/LAB/tejjer/node_modules/.pnpm/solid-start@0.2.6_i2cnpwj3ojjdnkycik5yjsstli/node_modules/solid-start/server/server-functions/browser.ts",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "vite:esbuild"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  redirect,\n  XSolidStartContentTypeHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\nimport { FETCH_EVENT } from \"../types\";\n\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport { CreateServerFunction, ServerFunction } from \"./types\";\n\nexport async function parseResponse(request: Request, response: Response) {\n  const contentType =\n    response.headers.get(XSolidStartContentTypeHeader) ||\n    response.headers.get(ContentTypeHeader) ||\n    \"\";\n  if (contentType.includes(\"json\")) {\n    return await response.json();\n  } else if (contentType.includes(\"text\")) {\n    return await response.text();\n  } else if (contentType.includes(\"server-error\")) {\n    const data = await response.json();\n    return new ServerError(data.error.message, {\n      stack: data.error.stack,\n      status: response.status\n    });\n  } else if (contentType.includes(\"form-error\")) {\n    const data = await response.json();\n    return new FormError(data.error.message, {\n      fieldErrors: data.error.fieldErrors,\n      fields: data.error.fields,\n      stack: data.error.stack\n    });\n  } else if (contentType.includes(\"error\")) {\n    const data = await response.json();\n    const error = new Error(data.error.message);\n    if (data.error.stack) {\n      error.stack = data.error.stack;\n    }\n    return error;\n  } else if (contentType.includes(\"response\")) {\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader)!);\n    }\n    return response;\n  } else {\n    if (response.status === 200) {\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch {}\n    }\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader)!);\n    }\n    return response;\n  }\n}\n\nexport const server$ = ((_fn: any) => {\n  throw new Error(\"Should be compiled away\");\n}) as unknown as CreateServerFunction;\n\nfunction createRequestInit(...args: any[]): RequestInit {\n  // parsing args when a request is made from the browser for a server module\n  // FormData\n  // Request\n  // Headers\n  //\n  let body,\n    headers: Record<string, string> = {\n      [XSolidStartOrigin]: \"client\"\n    };\n\n  if (args[0] instanceof FormData) {\n    body = args[0];\n  } else {\n    // special case for when server is used as fetcher for createResource\n    // we set {}.value to undefined. This keeps the createResource API intact as the type\n    // of this object is { value: T | undefined; refetching: boolean }\n    // So the user is expected to check value for undefined, and by setting it as undefined\n    // we can match user expectations that they dont have access to previous data on\n    // the server\n    if (Array.isArray(args) && args.length > 2) {\n      let secondArg = args[1];\n      if (typeof secondArg === \"object\" && \"value\" in secondArg && \"refetching\" in secondArg) {\n        secondArg.value = undefined;\n      }\n    }\n    body = JSON.stringify(args, (key, value) => {\n      if (value && typeof value === \"object\" && value.$type === FETCH_EVENT) {\n        return {\n          $type: \"fetch_event\"\n        };\n      }\n      if (value instanceof Headers) {\n        return {\n          $type: \"headers\",\n          values: [...value.entries()]\n        };\n      }\n      if (value instanceof Request) {\n        return {\n          $type: \"request\",\n          url: value.url,\n          method: value.method,\n          headers: value.headers\n        };\n      }\n      return value;\n    });\n    headers[ContentTypeHeader] = JSONResponseType;\n  }\n\n  return {\n    method: \"POST\",\n    body: body,\n    headers: new Headers({\n      ...headers\n    })\n  };\n}\n\ntype ServerCall = (route: string, init: RequestInit) => Promise<Response>;\n\nserver$.createFetcher = route => {\n  let fetcher: any = function (this: Request, ...args: any[]) {\n    if (this instanceof Request) {\n    }\n    const requestInit = createRequestInit(...args);\n    // request body: json, formData, or string\n    return (server$.call as ServerCall)(route, requestInit);\n  };\n\n  fetcher.url = route;\n  fetcher.fetch = (init: RequestInit) => (server$.call as ServerCall)(route, init);\n  // fetcher.action = async (...args: any[]) => {\n  //   const requestInit = createRequestInit(...args);\n  //   // request body: json, formData, or string\n  //   return server$.call(route, requestInit);\n  // };\n  return fetcher as ServerFunction<any, any>;\n};\n\nserver$.call = async function (route: string, init: RequestInit) {\n  const request = new Request(new URL(route, window.location.href).href, init);\n\n  const response = await fetch(request);\n\n  // // throws response, error, form error, json object, string\n  if (response.headers.get(XSolidStartResponseTypeHeader) === \"throw\") {\n    throw await parseResponse(request, response);\n  } else {\n    return await parseResponse(request, response);\n  }\n} as any;\n\n// used to fetch from an API route on the server or client, without falling into\n// fetch problems on the server\nserver$.fetch = async function (route: string | URL, init: RequestInit) {\n  if (route instanceof URL || route.startsWith(\"http\")) {\n    return await fetch(route, init);\n  }\n  const request = new Request(new URL(route, window.location.href).href, init);\n  return await fetch(request);\n};\n",
      "start": 1669937513093,
      "end": 1669937513220
    },
    {
      "name": "vite:esbuild",
      "result": "import {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  redirect,\n  XSolidStartContentTypeHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\nimport { FETCH_EVENT } from \"../types\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nexport async function parseResponse(request, response) {\n  const contentType = response.headers.get(XSolidStartContentTypeHeader) || response.headers.get(ContentTypeHeader) || \"\";\n  if (contentType.includes(\"json\")) {\n    return await response.json();\n  } else if (contentType.includes(\"text\")) {\n    return await response.text();\n  } else if (contentType.includes(\"server-error\")) {\n    const data = await response.json();\n    return new ServerError(data.error.message, {\n      stack: data.error.stack,\n      status: response.status\n    });\n  } else if (contentType.includes(\"form-error\")) {\n    const data = await response.json();\n    return new FormError(data.error.message, {\n      fieldErrors: data.error.fieldErrors,\n      fields: data.error.fields,\n      stack: data.error.stack\n    });\n  } else if (contentType.includes(\"error\")) {\n    const data = await response.json();\n    const error = new Error(data.error.message);\n    if (data.error.stack) {\n      error.stack = data.error.stack;\n    }\n    return error;\n  } else if (contentType.includes(\"response\")) {\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader));\n    }\n    return response;\n  } else {\n    if (response.status === 200) {\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch {\n      }\n    }\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader));\n    }\n    return response;\n  }\n}\nexport const server$ = (_fn) => {\n  throw new Error(\"Should be compiled away\");\n};\nfunction createRequestInit(...args) {\n  let body, headers = {\n    [XSolidStartOrigin]: \"client\"\n  };\n  if (args[0] instanceof FormData) {\n    body = args[0];\n  } else {\n    if (Array.isArray(args) && args.length > 2) {\n      let secondArg = args[1];\n      if (typeof secondArg === \"object\" && \"value\" in secondArg && \"refetching\" in secondArg) {\n        secondArg.value = void 0;\n      }\n    }\n    body = JSON.stringify(args, (key, value) => {\n      if (value && typeof value === \"object\" && value.$type === FETCH_EVENT) {\n        return {\n          $type: \"fetch_event\"\n        };\n      }\n      if (value instanceof Headers) {\n        return {\n          $type: \"headers\",\n          values: [...value.entries()]\n        };\n      }\n      if (value instanceof Request) {\n        return {\n          $type: \"request\",\n          url: value.url,\n          method: value.method,\n          headers: value.headers\n        };\n      }\n      return value;\n    });\n    headers[ContentTypeHeader] = JSONResponseType;\n  }\n  return {\n    method: \"POST\",\n    body,\n    headers: new Headers({\n      ...headers\n    })\n  };\n}\nserver$.createFetcher = (route) => {\n  let fetcher = function(...args) {\n    if (this instanceof Request) {\n    }\n    const requestInit = createRequestInit(...args);\n    return server$.call(route, requestInit);\n  };\n  fetcher.url = route;\n  fetcher.fetch = (init) => server$.call(route, init);\n  return fetcher;\n};\nserver$.call = async function(route, init) {\n  const request = new Request(new URL(route, window.location.href).href, init);\n  const response = await fetch(request);\n  if (response.headers.get(XSolidStartResponseTypeHeader) === \"throw\") {\n    throw await parseResponse(request, response);\n  } else {\n    return await parseResponse(request, response);\n  }\n};\nserver$.fetch = async function(route, init) {\n  if (route instanceof URL || route.startsWith(\"http\")) {\n    return await fetch(route, init);\n  }\n  const request = new Request(new URL(route, window.location.href).href, init);\n  return await fetch(request);\n};\n",
      "start": 1669937513220,
      "end": 1669937513491
    }
  ],
  "virtual": false
}