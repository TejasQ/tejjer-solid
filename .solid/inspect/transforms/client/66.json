{
  "id": "/Users/tejas/Sites/LAB/tejjer/node_modules/.pnpm/solid-start@0.2.6_i2cnpwj3ojjdnkycik5yjsstli/node_modules/solid-start/session/sessions.ts",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "vite:esbuild"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team:\n * https://github.com/remix-run/remix/blob/main/packages/remix-server-runtime/sessions.ts\n */\n\nimport type { CookieParseOptions, CookieSerializeOptions } from \"./cookie\";\n\nimport type { Cookie, CookieOptions, CreateCookieFunction } from \"./cookies\";\nimport { isCookie } from \"./cookies\";\n\nconst alreadyWarned: { [message: string]: boolean } = {};\n\nexport function warnOnce(condition: boolean, message: string): void {\n  if (!condition && !alreadyWarned[message]) {\n    alreadyWarned[message] = true;\n    console.warn(message);\n  }\n}\n\n/**\n * An object of name/value pairs to be used in the session.\n */\nexport interface SessionData {\n  [name: string]: any;\n}\n\n/**\n * Session persists data across HTTP requests.\n *\n * @see https://remix.run/api/remix#session-api\n */\nexport interface Session {\n  /**\n   * A unique identifier for this session.\n   *\n   * Note: This will be the empty string for newly created sessions and\n   * sessions that are not backed by a database (i.e. cookie-based sessions).\n   */\n  readonly id: string;\n\n  /**\n   * The raw data contained in this session.\n   *\n   * This is useful mostly for SessionStorage internally to access the raw\n   * session data to persist.\n   */\n  readonly data: SessionData;\n\n  /**\n   * Returns `true` if the session has a value for the given `name`, `false`\n   * otherwise.\n   */\n  has(name: string): boolean;\n\n  /**\n   * Returns the value for the given `name` in this session.\n   */\n  get(name: string): any;\n\n  /**\n   * Sets a value in the session for the given `name`.\n   */\n  set(name: string, value: any): void;\n\n  /**\n   * Sets a value in the session that is only valid until the next `get()`.\n   * This can be useful for temporary values, like error messages.\n   */\n  flash(name: string, value: any): void;\n\n  /**\n   * Removes a value from the session.\n   */\n  unset(name: string): void;\n}\n\nfunction flash(name: string): string {\n  return `__flash_${name}__`;\n}\n\nexport type CreateSessionFunction = (initialData?: SessionData, id?: string) => Session;\n\n/**\n * Creates a new Session object.\n *\n * Note: This function is typically not invoked directly by application code.\n * Instead, use a `SessionStorage` object's `getSession` method.\n *\n * @see https://remix.run/api/remix#createsession\n */\nexport const createSession: CreateSessionFunction = (initialData = {}, id = \"\") => {\n  let map = new Map<string, any>(Object.entries(initialData));\n\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name)) return map.get(name);\n\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n\n      return undefined;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\n\nexport type IsSessionFunction = (object: any) => object is Session;\n\n/**\n * Returns true if an object is a Remix session.\n *\n * @see https://remix.run/api/remix#issession\n */\nexport const isSession: IsSessionFunction = (object): object is Session => {\n  return (\n    object != null &&\n    typeof object.id === \"string\" &&\n    typeof object.data !== \"undefined\" &&\n    typeof object.has === \"function\" &&\n    typeof object.get === \"function\" &&\n    typeof object.set === \"function\" &&\n    typeof object.flash === \"function\" &&\n    typeof object.unset === \"function\"\n  );\n};\n\n/**\n * SessionStorage stores session data between HTTP requests and knows how to\n * parse and create cookies.\n *\n * A SessionStorage creates Session objects using a `Cookie` header as input.\n * Then, later it generates the `Set-Cookie` header to be used in the response.\n */\nexport interface SessionStorage {\n  /**\n   * Parses a Cookie header from a HTTP request and returns the associated\n   * Session. If there is no session associated with the cookie, this will\n   * return a new Session with no data.\n   */\n  getSession(cookieHeader?: string | null, options?: CookieParseOptions): Promise<Session>;\n\n  /**\n   * Stores all data in the Session and returns the Set-Cookie header to be\n   * used in the HTTP response.\n   */\n  commitSession(session: Session, options?: CookieSerializeOptions): Promise<string>;\n\n  /**\n   * Deletes all data associated with the Session and returns the Set-Cookie\n   * header to be used in the HTTP response.\n   */\n  destroySession(session: Session, options?: CookieSerializeOptions): Promise<string>;\n}\n\n/**\n * SessionIdStorageStrategy is designed to allow anyone to easily build their\n * own SessionStorage using `createSessionStorage(strategy)`.\n *\n * This strategy describes a common scenario where the session id is stored in\n * a cookie but the actual session data is stored elsewhere, usually in a\n * database or on disk. A set of create, read, update, and delete operations\n * are provided for managing the session data.\n */\nexport interface SessionIdStorageStrategy {\n  /**\n   * The Cookie used to store the session id, or options used to automatically\n   * create one.\n   */\n  cookie?: Cookie | (CookieOptions & { name?: string });\n\n  /**\n   * Creates a new record with the given data and returns the session id.\n   */\n  createData: (data: SessionData, expires?: Date) => Promise<string>;\n\n  /**\n   * Returns data for a given session id, or `null` if there isn't any.\n   */\n  readData: (id: string) => Promise<SessionData | null>;\n\n  /**\n   * Updates data for the given session id.\n   */\n  updateData: (id: string, data: SessionData, expires?: Date) => Promise<void>;\n\n  /**\n   * Deletes data for a given session id from the data store.\n   */\n  deleteData: (id: string) => Promise<void>;\n}\n\nexport type CreateSessionStorageFunction = (strategy: SessionIdStorageStrategy) => SessionStorage;\n\n/**\n * Creates a SessionStorage object using a SessionIdStorageStrategy.\n *\n * Note: This is a low-level API that should only be used if none of the\n * existing session storage options meet your requirements.\n *\n * @see https://remix.run/api/remix#createsessionstorage\n */\nexport const createSessionStorageFactory =\n  (createCookie: CreateCookieFunction): CreateSessionStorageFunction =>\n  ({ cookie: cookieArg, createData, readData, updateData, deleteData }) => {\n    let cookie = isCookie(cookieArg)\n      ? cookieArg\n      : createCookie(cookieArg?.name || \"__session\", cookieArg);\n\n    warnOnceAboutSigningSessionCookie(cookie);\n\n    return {\n      async getSession(cookieHeader, options) {\n        let id = cookieHeader && (await cookie.parse(cookieHeader, options));\n        let data = id && (await readData(id));\n        return createSession(data || {}, id || \"\");\n      },\n      async commitSession(session, options) {\n        let { id, data } = session;\n\n        if (id) {\n          await updateData(id, data, cookie.expires);\n        } else {\n          id = await createData(data, cookie.expires);\n        }\n\n        return cookie.serialize(id, options);\n      },\n      async destroySession(session, options) {\n        await deleteData(session.id);\n        return cookie.serialize(\"\", {\n          ...options,\n          expires: new Date(0)\n        });\n      }\n    };\n  };\n\nexport function warnOnceAboutSigningSessionCookie(cookie: Cookie) {\n  warnOnce(\n    cookie.isSigned,\n    `The \"${cookie.name}\" cookie is not signed, but session cookies should be ` +\n      `signed to prevent tampering on the client before they are sent back to the ` +\n      `server. See https://remix.run/api/remix#signing-cookies ` +\n      `for more information.`\n  );\n}\n",
      "start": 1669937513088,
      "end": 1669937513200
    },
    {
      "name": "vite:esbuild",
      "result": "/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team:\n * https://github.com/remix-run/remix/blob/main/packages/remix-server-runtime/sessions.ts\n */\nimport { isCookie } from \"./cookies\";\nconst alreadyWarned = {};\nexport function warnOnce(condition, message) {\n  if (!condition && !alreadyWarned[message]) {\n    alreadyWarned[message] = true;\n    console.warn(message);\n  }\n}\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\nexport const createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name))\n        return map.get(name);\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n      return void 0;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\nexport const isSession = (object) => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nexport const createSessionStorageFactory = (createCookie) => ({ cookie: cookieArg, createData, readData, updateData, deleteData }) => {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && await cookie.parse(cookieHeader, options);\n      let data = id && await readData(id);\n      return createSession(data || {}, id || \"\");\n    },\n    async commitSession(session, options) {\n      let { id, data } = session;\n      if (id) {\n        await updateData(id, data, cookie.expires);\n      } else {\n        id = await createData(data, cookie.expires);\n      }\n      return cookie.serialize(id, options);\n    },\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", {\n        ...options,\n        expires: new Date(0)\n      });\n    }\n  };\n};\nexport function warnOnceAboutSigningSessionCookie(cookie) {\n  warnOnce(\n    cookie.isSigned,\n    `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/api/remix#signing-cookies for more information.`\n  );\n}\n",
      "start": 1669937513200,
      "end": 1669937513295
    }
  ],
  "virtual": false
}