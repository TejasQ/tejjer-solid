{
  "id": "/Users/tejas/Sites/LAB/tejjer/node_modules/.pnpm/solid-start@0.2.6_i2cnpwj3ojjdnkycik5yjsstli/node_modules/solid-start/server/server-functions/server.ts",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "vite:esbuild",
    "vite:define"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { sharedConfig } from \"solid-js\";\nimport { internalFetch } from \"../../api/internalFetch\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport {\n  ContentTypeHeader,\n  isRedirectResponse,\n  JSONResponseType,\n  LocationHeader,\n  ResponseError,\n  XSolidStartContentTypeHeader,\n  XSolidStartLocationHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\nimport { PageEvent, ServerFunctionEvent } from \"../types\";\nimport { CreateServerFunction } from \"./types\";\nexport type { APIEvent } from \"../../api/types\";\n\nexport const server$: CreateServerFunction = ((_fn: any) => {\n  throw new Error(\"Should be compiled away\");\n}) as unknown as CreateServerFunction;\n\nasync function parseRequest(event: ServerFunctionEvent) {\n  let request = event.request;\n  let contentType = request.headers.get(ContentTypeHeader);\n  let name = new URL(request.url).pathname,\n    args = [];\n\n  if (contentType) {\n    if (contentType === JSONResponseType) {\n      let text = await request.text();\n      try {\n        args = JSON.parse(text, (key: string, value: any) => {\n          if (!value) {\n            return value;\n          }\n          if (value.$type === \"fetch_event\") {\n            return event;\n          }\n          if (value.$type === \"headers\") {\n            let headers = new Headers();\n            request.headers.forEach((value, key) => headers.set(key, value));\n            value.values.forEach(([key, value]: [string, any]) => headers.set(key, value));\n            return headers;\n          }\n          if (value.$type === \"request\") {\n            return new Request(value.url, {\n              method: value.method,\n              headers: value.headers\n            });\n          }\n          return value;\n        });\n      } catch (e) {\n        throw new Error(`Error parsing request body: ${text}`);\n      }\n    } else if (contentType.includes(\"form\")) {\n      let formData = await request.clone().formData();\n      args = [formData, event];\n    }\n  }\n  return [name, args] as const;\n}\n\nexport function respondWith(\n  request: Request,\n  data: Response | Error | FormError | string | object,\n  responseType: \"throw\" | \"return\"\n) {\n  if (data instanceof ResponseError) {\n    data = data.clone();\n  }\n\n  if (data instanceof Response) {\n    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === \"client\") {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader)!);\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(null, {\n        status: 204,\n        statusText: \"Redirected\",\n        headers: headers\n      });\n    } else if (data.status === 101) {\n      // this is a websocket upgrade, so we don't want to modify the response\n      return data;\n    } else {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n\n      return new Response(data.body, {\n        status: data.status,\n        statusText: data.statusText,\n        headers\n      });\n    }\n  } else if (data instanceof FormError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV\n            ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\\n\\n${data.stack}`\n            : \"\",\n          formError: data.formError,\n          fields: data.fields,\n          fieldErrors: data.fieldErrors\n        }\n      }),\n      {\n        status: 400,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"form-error\"\n        }\n      }\n    );\n  } else if (data instanceof ServerError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV\n            ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\\n\\n${data.stack}`\n            : \"\"\n        }\n      }),\n      {\n        status: data.status,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"server-error\"\n        }\n      }\n    );\n  } else if (data instanceof Error) {\n    console.error(data);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: import.meta.env.DEV\n            ? `Internal Server Error (${data.message})`\n            : \"Internal Server Error\",\n          stack: import.meta.env.DEV\n            ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \\n\\n${data.stack}`\n            : \"\",\n          status: (data as any).status\n        }\n      }),\n      {\n        status: (data as any).status || 500,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"error\"\n        }\n      }\n    );\n  } else if (\n    typeof data === \"object\" ||\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\"\n  ) {\n    return new Response(JSON.stringify(data), {\n      status: 200,\n      headers: {\n        [ContentTypeHeader]: \"application/json\",\n        [XSolidStartResponseTypeHeader]: responseType,\n        [XSolidStartContentTypeHeader]: \"json\"\n      }\n    });\n  }\n\n  return new Response(\"null\", {\n    status: 200,\n    headers: {\n      [ContentTypeHeader]: \"application/json\",\n      [XSolidStartContentTypeHeader]: \"json\",\n      [XSolidStartResponseTypeHeader]: responseType\n    }\n  });\n}\n\nexport async function handleServerRequest(event: ServerFunctionEvent) {\n  const url = new URL(event.request.url);\n\n  if (server$.hasHandler(url.pathname)) {\n    try {\n      let [name, args] = await parseRequest(event);\n      let handler = server$.getHandler(name);\n      if (!handler) {\n        throw {\n          status: 404,\n          message: \"Handler Not Found for \" + name\n        };\n      }\n      const data = await handler.call(event, ...(Array.isArray(args) ? args : [args]));\n      return respondWith(event.request, data, \"return\");\n    } catch (error) {\n      return respondWith(event.request, error as Error, \"throw\");\n    }\n  }\n\n  return null;\n}\n\nconst handlers = new Map();\n// server$.requestContext = null;\nserver$.createHandler = (_fn, hash) => {\n  // this is run in two ways:\n  // called on the server while rendering the App, eg. in a routeData function\n  // - pass args as is to the fn, they should maintain identity since they are passed by reference\n  // - pass the response/throw the response, as you get it,\n  // - except when its a redirect and you are rendering the App,\n  //     - then we need to somehow communicate to the central server that this request is a redirect and should set the appropriate headers and status code\n  // called on the server when an HTTP request for this server function is made to the server (by a client)\n  // - request is parsed to figure out the args that need to be passed here, we still pass the same args as above, but they are not the same reference\n  //   as the ones passed in the client. They are cloned and serialized and made as similar to the ones passed in the client as possible\n  let fn: any = function (this: PageEvent | any, ...args: any[]) {\n    let ctx: any | undefined;\n\n    // if called with fn.call(...), we check if we got a valid RequestContext, and use that as\n    // the request context for this server function call\n    if (typeof this === \"object\") {\n      ctx = this;\n      // @ts-ignore\n    } else if (sharedConfig.context && sharedConfig.context.requestContext) {\n      // otherwise we check if the sharedConfig has a requestContext, and use that as the request context\n      // people shouldn't rely on this\n      // @ts-ignore\n      ctx = sharedConfig.context.requestContext;\n    } else {\n      // this is normally used during a test\n      ctx = {\n        request: new URL(hash, \"http://localhost:3000\").href,\n        responseHeaders: new Headers()\n      } as any;\n    }\n\n    const execute = async () => {\n      try {\n        let e = await _fn.call(ctx, ...args);\n        return e;\n      } catch (e) {\n        if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {\n          const error = new Error(\n            e.message +\n              \"\\n\" +\n              \" You probably are using a variable defined in a closure in your server function.\"\n          );\n          error.stack = e.stack;\n          throw error;\n        }\n        throw e;\n      }\n    };\n\n    return execute();\n  };\n\n  fn.url = hash;\n  fn.action = function (...args: any[]) {\n    return fn.call(this, ...args);\n  };\n\n  return fn;\n};\n\nserver$.registerHandler = function (route, handler) {\n  handlers.set(route, handler);\n};\n\nserver$.getHandler = function (route) {\n  return handlers.get(route);\n};\n\nserver$.hasHandler = function (route) {\n  return handlers.has(route);\n};\n\n// used to fetch from an API route on the server or client, without falling into\n// fetch problems on the server\nserver$.fetch = internalFetch;\n",
      "start": 1669937513942,
      "end": 1669937513976
    },
    {
      "name": "vite:esbuild",
      "result": "import { sharedConfig } from \"solid-js\";\nimport { internalFetch } from \"../../api/internalFetch\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport {\n  ContentTypeHeader,\n  isRedirectResponse,\n  JSONResponseType,\n  LocationHeader,\n  ResponseError,\n  XSolidStartContentTypeHeader,\n  XSolidStartLocationHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\nexport const server$ = (_fn) => {\n  throw new Error(\"Should be compiled away\");\n};\nasync function parseRequest(event) {\n  let request = event.request;\n  let contentType = request.headers.get(ContentTypeHeader);\n  let name = new URL(request.url).pathname, args = [];\n  if (contentType) {\n    if (contentType === JSONResponseType) {\n      let text = await request.text();\n      try {\n        args = JSON.parse(text, (key, value) => {\n          if (!value) {\n            return value;\n          }\n          if (value.$type === \"fetch_event\") {\n            return event;\n          }\n          if (value.$type === \"headers\") {\n            let headers = new Headers();\n            request.headers.forEach((value2, key2) => headers.set(key2, value2));\n            value.values.forEach(([key2, value2]) => headers.set(key2, value2));\n            return headers;\n          }\n          if (value.$type === \"request\") {\n            return new Request(value.url, {\n              method: value.method,\n              headers: value.headers\n            });\n          }\n          return value;\n        });\n      } catch (e) {\n        throw new Error(`Error parsing request body: ${text}`);\n      }\n    } else if (contentType.includes(\"form\")) {\n      let formData = await request.clone().formData();\n      args = [formData, event];\n    }\n  }\n  return [name, args];\n}\nexport function respondWith(request, data, responseType) {\n  if (data instanceof ResponseError) {\n    data = data.clone();\n  }\n  if (data instanceof Response) {\n    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === \"client\") {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader));\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(null, {\n        status: 204,\n        statusText: \"Redirected\",\n        headers\n      });\n    } else if (data.status === 101) {\n      return data;\n    } else {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(data.body, {\n        status: data.status,\n        statusText: data.statusText,\n        headers\n      });\n    }\n  } else if (data instanceof FormError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\",\n          formError: data.formError,\n          fields: data.fields,\n          fieldErrors: data.fieldErrors\n        }\n      }),\n      {\n        status: 400,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"form-error\"\n        }\n      }\n    );\n  } else if (data instanceof ServerError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: import.meta.env.DEV ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\"\n        }\n      }),\n      {\n        status: data.status,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"server-error\"\n        }\n      }\n    );\n  } else if (data instanceof Error) {\n    console.error(data);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: import.meta.env.DEV ? `Internal Server Error (${data.message})` : \"Internal Server Error\",\n          stack: import.meta.env.DEV ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \n\n${data.stack}` : \"\",\n          status: data.status\n        }\n      }),\n      {\n        status: data.status || 500,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"error\"\n        }\n      }\n    );\n  } else if (typeof data === \"object\" || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\") {\n    return new Response(JSON.stringify(data), {\n      status: 200,\n      headers: {\n        [ContentTypeHeader]: \"application/json\",\n        [XSolidStartResponseTypeHeader]: responseType,\n        [XSolidStartContentTypeHeader]: \"json\"\n      }\n    });\n  }\n  return new Response(\"null\", {\n    status: 200,\n    headers: {\n      [ContentTypeHeader]: \"application/json\",\n      [XSolidStartContentTypeHeader]: \"json\",\n      [XSolidStartResponseTypeHeader]: responseType\n    }\n  });\n}\nexport async function handleServerRequest(event) {\n  const url = new URL(event.request.url);\n  if (server$.hasHandler(url.pathname)) {\n    try {\n      let [name, args] = await parseRequest(event);\n      let handler = server$.getHandler(name);\n      if (!handler) {\n        throw {\n          status: 404,\n          message: \"Handler Not Found for \" + name\n        };\n      }\n      const data = await handler.call(event, ...Array.isArray(args) ? args : [args]);\n      return respondWith(event.request, data, \"return\");\n    } catch (error) {\n      return respondWith(event.request, error, \"throw\");\n    }\n  }\n  return null;\n}\nconst handlers = /* @__PURE__ */ new Map();\nserver$.createHandler = (_fn, hash) => {\n  let fn = function(...args) {\n    let ctx;\n    if (typeof this === \"object\") {\n      ctx = this;\n    } else if (sharedConfig.context && sharedConfig.context.requestContext) {\n      ctx = sharedConfig.context.requestContext;\n    } else {\n      ctx = {\n        request: new URL(hash, \"http://localhost:3000\").href,\n        responseHeaders: new Headers()\n      };\n    }\n    const execute = async () => {\n      try {\n        let e = await _fn.call(ctx, ...args);\n        return e;\n      } catch (e) {\n        if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {\n          const error = new Error(\n            e.message + \"\\n You probably are using a variable defined in a closure in your server function.\"\n          );\n          error.stack = e.stack;\n          throw error;\n        }\n        throw e;\n      }\n    };\n    return execute();\n  };\n  fn.url = hash;\n  fn.action = function(...args) {\n    return fn.call(this, ...args);\n  };\n  return fn;\n};\nserver$.registerHandler = function(route, handler) {\n  handlers.set(route, handler);\n};\nserver$.getHandler = function(route) {\n  return handlers.get(route);\n};\nserver$.hasHandler = function(route) {\n  return handlers.has(route);\n};\nserver$.fetch = internalFetch;\n",
      "start": 1669937513976,
      "end": 1669937514073
    },
    {
      "name": "vite:define",
      "result": "import { sharedConfig } from \"solid-js\";\nimport { internalFetch } from \"../../api/internalFetch\";\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport {\n  ContentTypeHeader,\n  isRedirectResponse,\n  JSONResponseType,\n  LocationHeader,\n  ResponseError,\n  XSolidStartContentTypeHeader,\n  XSolidStartLocationHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\nexport const server$ = (_fn) => {\n  throw new Error(\"Should be compiled away\");\n};\nasync function parseRequest(event) {\n  let request = event.request;\n  let contentType = request.headers.get(ContentTypeHeader);\n  let name = new URL(request.url).pathname, args = [];\n  if (contentType) {\n    if (contentType === JSONResponseType) {\n      let text = await request.text();\n      try {\n        args = JSON.parse(text, (key, value) => {\n          if (!value) {\n            return value;\n          }\n          if (value.$type === \"fetch_event\") {\n            return event;\n          }\n          if (value.$type === \"headers\") {\n            let headers = new Headers();\n            request.headers.forEach((value2, key2) => headers.set(key2, value2));\n            value.values.forEach(([key2, value2]) => headers.set(key2, value2));\n            return headers;\n          }\n          if (value.$type === \"request\") {\n            return new Request(value.url, {\n              method: value.method,\n              headers: value.headers\n            });\n          }\n          return value;\n        });\n      } catch (e) {\n        throw new Error(`Error parsing request body: ${text}`);\n      }\n    } else if (contentType.includes(\"form\")) {\n      let formData = await request.clone().formData();\n      args = [formData, event];\n    }\n  }\n  return [name, args];\n}\nexport function respondWith(request, data, responseType) {\n  if (data instanceof ResponseError) {\n    data = data.clone();\n  }\n  if (data instanceof Response) {\n    if (isRedirectResponse(data) && request.headers.get(XSolidStartOrigin) === \"client\") {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartLocationHeader, data.headers.get(LocationHeader));\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(null, {\n        status: 204,\n        statusText: \"Redirected\",\n        headers\n      });\n    } else if (data.status === 101) {\n      return data;\n    } else {\n      let headers = new Headers(data.headers);\n      headers.set(XSolidStartOrigin, \"server\");\n      headers.set(XSolidStartResponseTypeHeader, responseType);\n      headers.set(XSolidStartContentTypeHeader, \"response\");\n      return new Response(data.body, {\n        status: data.status,\n        statusText: data.statusText,\n        headers\n      });\n    }\n  } else if (data instanceof FormError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: false ? `The stack for FormErrors are only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\",\n          formError: data.formError,\n          fields: data.fields,\n          fieldErrors: data.fieldErrors\n        }\n      }),\n      {\n        status: 400,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"form-error\"\n        }\n      }\n    );\n  } else if (data instanceof ServerError) {\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: data.message,\n          stack: false ? `The stack for ServerErrors is only logged during development. In production you should handle these errors with an ErrorBoundary that can display the error message appropriately to the user.\n\n${data.stack}` : \"\"\n        }\n      }),\n      {\n        status: data.status,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"server-error\"\n        }\n      }\n    );\n  } else if (data instanceof Error) {\n    console.error(data);\n    return new Response(\n      JSON.stringify({\n        error: {\n          message: false ? `Internal Server Error (${data.message})` : \"Internal Server Error\",\n          stack: false ? `This error happened inside a server function and you didn't handle it. So the client will receive an Internal Server Error. You can catch the error and throw a ServerError that makes sense for your UI. In production, the user will have no idea what the error is: \n\n${data.stack}` : \"\",\n          status: data.status\n        }\n      }),\n      {\n        status: data.status || 500,\n        headers: {\n          [XSolidStartResponseTypeHeader]: responseType,\n          [XSolidStartContentTypeHeader]: \"error\"\n        }\n      }\n    );\n  } else if (typeof data === \"object\" || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\") {\n    return new Response(JSON.stringify(data), {\n      status: 200,\n      headers: {\n        [ContentTypeHeader]: \"application/json\",\n        [XSolidStartResponseTypeHeader]: responseType,\n        [XSolidStartContentTypeHeader]: \"json\"\n      }\n    });\n  }\n  return new Response(\"null\", {\n    status: 200,\n    headers: {\n      [ContentTypeHeader]: \"application/json\",\n      [XSolidStartContentTypeHeader]: \"json\",\n      [XSolidStartResponseTypeHeader]: responseType\n    }\n  });\n}\nexport async function handleServerRequest(event) {\n  const url = new URL(event.request.url);\n  if (server$.hasHandler(url.pathname)) {\n    try {\n      let [name, args] = await parseRequest(event);\n      let handler = server$.getHandler(name);\n      if (!handler) {\n        throw {\n          status: 404,\n          message: \"Handler Not Found for \" + name\n        };\n      }\n      const data = await handler.call(event, ...Array.isArray(args) ? args : [args]);\n      return respondWith(event.request, data, \"return\");\n    } catch (error) {\n      return respondWith(event.request, error, \"throw\");\n    }\n  }\n  return null;\n}\nconst handlers = /* @__PURE__ */ new Map();\nserver$.createHandler = (_fn, hash) => {\n  let fn = function(...args) {\n    let ctx;\n    if (typeof this === \"object\") {\n      ctx = this;\n    } else if (sharedConfig.context && sharedConfig.context.requestContext) {\n      ctx = sharedConfig.context.requestContext;\n    } else {\n      ctx = {\n        request: new URL(hash, \"http://localhost:3000\").href,\n        responseHeaders: new Headers()\n      };\n    }\n    const execute = async () => {\n      try {\n        let e = await _fn.call(ctx, ...args);\n        return e;\n      } catch (e) {\n        if (e instanceof Error && /[A-Za-z]+ is not defined/.test(e.message)) {\n          const error = new Error(\n            e.message + \"\\n You probably are using a variable defined in a closure in your server function.\"\n          );\n          error.stack = e.stack;\n          throw error;\n        }\n        throw e;\n      }\n    };\n    return execute();\n  };\n  fn.url = hash;\n  fn.action = function(...args) {\n    return fn.call(this, ...args);\n  };\n  return fn;\n};\nserver$.registerHandler = function(route, handler) {\n  handlers.set(route, handler);\n};\nserver$.getHandler = function(route) {\n  return handlers.get(route);\n};\nserver$.hasHandler = function(route) {\n  return handlers.has(route);\n};\nserver$.fetch = internalFetch;\n",
      "start": 1669937514074,
      "end": 1669937514074
    }
  ],
  "virtual": false
}