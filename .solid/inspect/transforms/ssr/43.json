{
  "id": "/Users/tejas/Sites/LAB/tejjer/node_modules/.pnpm/solid-start@0.2.6_i2cnpwj3ojjdnkycik5yjsstli/node_modules/solid-start/islands/server-router.tsx",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "solid"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { createContext, JSX, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nexport interface RouteDefinition {\n  path: string;\n  component?: () => JSX.Element;\n  children?: RouteDefinition | RouteDefinition[];\n}\n\nexport type Params = Record<string, string>;\n\nexport interface PathMatch {\n  params: Params;\n  path: string;\n}\n\nexport interface MatchedRoute {\n  id: string;\n  originalPath: string;\n  pattern: string;\n  component: (props: any) => JSX.Element;\n  match: PathMatch;\n  shared: boolean;\n}\n\nexport interface Branch {\n  routes: MatchedRoute[];\n  score: number;\n}\n\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\n\nfunction normalize(path: string) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? (s.startsWith(\"?\") ? s : \"/\" + s) : \"\";\n}\n\nexport function resolvePath(base: string, path: string, from?: string): string | undefined {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\n\nexport function joinPaths(from: string, to: string): string {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\n\nexport function matchPath(path: string, location: string, partial?: boolean): PathMatch | null {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n    return null;\n  }\n\n  const match: PathMatch = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, undefined, { sensitivity: \"base\" }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n\n  return match;\n}\n\nexport function scoreRoute(route: MatchedRoute): number {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce(\n    (score, segment) => score + (segment.startsWith(\":\") ? 2 : 3),\n    segments.length - (splat === undefined ? 0 : 1)\n  );\n}\n\nexport function createMatchedRoute(\n  routeDef: RouteDefinition,\n  base: string,\n  id: string,\n  location: string\n): MatchedRoute | null {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n\n  const { path: originalPath, component = Outlet, children } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\n\nexport function getMatchedBranch(\n  routeDef: RouteDefinition | RouteDefinition[],\n  location: string,\n  stack: MatchedRoute[] = [],\n  branches: Branch[] = []\n): Branch | null {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(\n      def,\n      parent ? parent.pattern : \"/\",\n      parent ? `${parent.id}.${i}` : \"\" + i,\n      location\n    );\n\n    if (route) {\n      stack.push(route);\n\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n\n      stack.pop();\n    }\n  }\n\n  return branches[0] || null;\n}\n\nexport interface RouterContextState {\n  routes: MatchedRoute[];\n  location: string;\n}\n\nexport const RouterContext = createContext<RouterContextState>();\n\nexport const useRouter = () => useContext(RouterContext)!;\n\nexport interface OutletContextState {\n  depth: number;\n  route: MatchedRoute;\n}\n\nexport const OutletContext = createContext<OutletContextState>();\n\nexport const useOutlet = () => useContext(OutletContext);\n\nexport const useRouteParams = () => {\n  const outlet = useOutlet()!;\n  return () => outlet.route.match.params;\n};\n\nexport interface RouterProps {\n  location: string;\n  prevLocation: string;\n  routes: RouteDefinition | RouteDefinition[];\n  children: JSX.Element;\n  out?: any;\n}\n\nexport function Router(props: RouterProps) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n\n  const nextRoutes = next.routes;\n\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (\n        prevRoute &&\n        nextRoute.id === prevRoute.id &&\n        nextRoute.match.path === prevRoute.match.path\n      ) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          // console.log(\"diff rendered\");\n          // const Comp = nextRoute.component;\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n          // diffedRender = (\n          //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n          //     <Comp />\n          //   </outlet-wrapper>\n          // );\n          // return diffedRender;\n        }\n        // Routes are shared\n      } else {\n        // console.log(\"diff rendered\");\n        // const Comp = nextRoute.component;\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n        //console.log(prevRoute, nextRoute);\n        //console.log(`diff render from: ${props.prevLocation} to: ${props.location}`);\n        // diffedRender = (\n        //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n        //     <Comp />\n        //   </outlet-wrapper>\n        // );\n        // return diffedRender;\n      }\n    }\n  }\n\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n\n  return <RouterContext.Provider value={state}>{props.children}</RouterContext.Provider>;\n}\n\nexport function Outlet(props: { children: JSX.Element }) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n\n  return (\n    <>\n      {ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`)}\n      <OutletContext.Provider value={state}>{props.children}</OutletContext.Provider>\n      {ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)}\n    </>\n  );\n}\n",
      "start": 1669937513815,
      "end": 1669937513831
    },
    {
      "name": "solid",
      "result": "import { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$|\\s+/g;\nfunction normalize(path) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? s.startsWith(\"?\") ? s : \"/\" + s : \"\";\n}\nexport function resolvePath(base, path, from) {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\nexport function joinPaths(from, to) {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\nexport function matchPath(path, location, partial) {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const locSegments = location.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || lenDiff > 0 && splat === undefined && !partial) {\n    return null;\n  }\n  const match = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, undefined, {\n      sensitivity: \"base\"\n    }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n  return match;\n}\nexport function scoreRoute(route) {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMatchedRoute(routeDef, base, id, location) {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n  const {\n    path: originalPath,\n    component = Outlet,\n    children\n  } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    match,\n    shared: false\n  };\n}\nexport function getMatchedBranch(routeDef, location, stack = [], branches = []) {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(def, parent ? parent.pattern : \"/\", parent ? `${parent.id}.${i}` : \"\" + i, location);\n    if (route) {\n      stack.push(route);\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n      stack.pop();\n    }\n  }\n  return branches[0] || null;\n}\nexport const RouterContext = createContext();\nexport const useRouter = () => useContext(RouterContext);\nexport const OutletContext = createContext();\nexport const useOutlet = () => useContext(OutletContext);\nexport const useRouteParams = () => {\n  const outlet = useOutlet();\n  return () => outlet.route.match.params;\n};\nexport function Router(props) {\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n  const nextRoutes = next.routes;\n  const prev = props.prevLocation ? getMatchedBranch(props.routes, props.prevLocation) : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (prevRoute && nextRoute.id === prevRoute.id && nextRoute.match.path === prevRoute.match.path) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          // console.log(\"diff rendered\");\n          // const Comp = nextRoute.component;\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n          // diffedRender = (\n          //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n          //     <Comp />\n          //   </outlet-wrapper>\n          // );\n          // return diffedRender;\n        }\n        // Routes are shared\n      } else {\n        // console.log(\"diff rendered\");\n        // const Comp = nextRoute.component;\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n        //console.log(prevRoute, nextRoute);\n        //console.log(`diff render from: ${props.prevLocation} to: ${props.location}`);\n        // diffedRender = (\n        //   <outlet-wrapper id={`outlet-${nextRoute.id}`}>\n        //     <Comp />\n        //   </outlet-wrapper>\n        // );\n        // return diffedRender;\n      }\n    }\n  }\n\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n  return _$createComponent(RouterContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  });\n}\nexport function Outlet(props) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n  return [ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`), _$createComponent(OutletContext.Provider, {\n    value: state,\n    get children() {\n      return props.children;\n    }\n  }), ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)];\n}",
      "start": 1669937513831,
      "end": 1669937513841
    }
  ],
  "virtual": false
}