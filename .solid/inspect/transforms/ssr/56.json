{
  "id": "/Users/tejas/Sites/LAB/tejjer/node_modules/.pnpm/solid-start@0.2.6_i2cnpwj3ojjdnkycik5yjsstli/node_modules/solid-start/server/middleware.ts",
  "deps": [],
  "plugins": [
    "vite:load-fallback",
    "vite:esbuild"
  ],
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { internalFetch } from \"../api/internalFetch\";\nimport { Middleware as ServerMiddleware } from \"../entry-server/StartServer\";\nimport { ContentTypeHeader, XSolidStartContentTypeHeader, XSolidStartOrigin } from \"./responses\";\nimport { handleServerRequest, server$ } from \"./server-functions/server\";\nimport { FetchEvent, FETCH_EVENT } from \"./types\";\n\nexport const inlineServerFunctions: ServerMiddleware = ({ forward }) => {\n  return async (event: FetchEvent) => {\n    const url = new URL(event.request.url);\n\n    if (server$.hasHandler(url.pathname)) {\n      let contentType = event.request.headers.get(ContentTypeHeader);\n      let origin = event.request.headers.get(XSolidStartOrigin);\n\n      let formRequestBody;\n      if (\n        contentType != null &&\n        contentType.includes(\"form\") &&\n        !(origin != null && origin.includes(\"client\"))\n      ) {\n        let [read1, read2] = event.request.body!.tee();\n        formRequestBody = new Request(event.request.url, {\n          body: read2,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n        event.request = new Request(event.request.url, {\n          body: read1,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n      }\n\n      let serverFunctionEvent = Object.freeze({\n        request: event.request,\n        fetch: internalFetch,\n        $type: FETCH_EVENT,\n        env: event.env\n      });\n\n      const serverResponse = await handleServerRequest(serverFunctionEvent);\n\n      let responseContentType = serverResponse!.headers.get(XSolidStartContentTypeHeader);\n\n      // when a form POST action is made and there is an error throw,\n      // and its a non-javascript request potentially,\n      // we redirect to the referrer with the form state and error serialized\n      // in the url params for the redicted location\n      if (\n        formRequestBody &&\n        responseContentType !== null &&\n        responseContentType.includes(\"error\")\n      ) {\n        const formData = await formRequestBody.formData();\n        let entries = [...formData.entries()];\n        return new Response(null, {\n          status: 302,\n          headers: {\n            Location:\n              new URL(event.request.headers.get(\"referer\") || \"\").pathname +\n              \"?form=\" +\n              encodeURIComponent(\n                JSON.stringify({\n                  url: url.pathname,\n                  entries: entries,\n                  ...(await serverResponse!.json())\n                })\n              )\n          }\n        });\n      }\n      return serverResponse as Response;\n    }\n\n    const response = await forward(event);\n\n    return response;\n  };\n};\n",
      "start": 1669937513815,
      "end": 1669937513861
    },
    {
      "name": "vite:esbuild",
      "result": "import { internalFetch } from \"../api/internalFetch\";\nimport { ContentTypeHeader, XSolidStartContentTypeHeader, XSolidStartOrigin } from \"./responses\";\nimport { handleServerRequest, server$ } from \"./server-functions/server\";\nimport { FETCH_EVENT } from \"./types\";\nexport const inlineServerFunctions = ({ forward }) => {\n  return async (event) => {\n    const url = new URL(event.request.url);\n    if (server$.hasHandler(url.pathname)) {\n      let contentType = event.request.headers.get(ContentTypeHeader);\n      let origin = event.request.headers.get(XSolidStartOrigin);\n      let formRequestBody;\n      if (contentType != null && contentType.includes(\"form\") && !(origin != null && origin.includes(\"client\"))) {\n        let [read1, read2] = event.request.body.tee();\n        formRequestBody = new Request(event.request.url, {\n          body: read2,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n        event.request = new Request(event.request.url, {\n          body: read1,\n          headers: event.request.headers,\n          method: event.request.method,\n          duplex: \"half\"\n        });\n      }\n      let serverFunctionEvent = Object.freeze({\n        request: event.request,\n        fetch: internalFetch,\n        $type: FETCH_EVENT,\n        env: event.env\n      });\n      const serverResponse = await handleServerRequest(serverFunctionEvent);\n      let responseContentType = serverResponse.headers.get(XSolidStartContentTypeHeader);\n      if (formRequestBody && responseContentType !== null && responseContentType.includes(\"error\")) {\n        const formData = await formRequestBody.formData();\n        let entries = [...formData.entries()];\n        return new Response(null, {\n          status: 302,\n          headers: {\n            Location: new URL(event.request.headers.get(\"referer\") || \"\").pathname + \"?form=\" + encodeURIComponent(\n              JSON.stringify({\n                url: url.pathname,\n                entries,\n                ...await serverResponse.json()\n              })\n            )\n          }\n        });\n      }\n      return serverResponse;\n    }\n    const response = await forward(event);\n    return response;\n  };\n};\n",
      "start": 1669937513861,
      "end": 1669937513940
    }
  ],
  "virtual": false
}